<div style="padding: 24px; background-color: white; height: 100%;">
  <div>
    <h1>Angular API</h1>
  </div>

  <div style="width: 100%;" class="card card-detail pr-five">
    <div class="card-wrapper pr-five">
      <div class="card-header pr-five">NgContent, NgTemplate, NgContainer, NgTemplateOutlet</div>
      <div class="card-content pr-five">
        <div>Позволяют создавать динамичные и настраиваемые компоненты.</div>
        <div>
          NgContent позволяет родительским компонентам внедрять код html в дочерние компоненты
        </div>
        <div>
          NgTemplate: директив-шаблон, контент которой может быть отображен в другом месте.
        </div>
        <div>
          NgContainer: позволяет применить структурную директиву к разделу страницы, не создавай при этом дополнительный элемент
        </div>
        <div>
          NgTemplateOutlet: может взять NgTemplate шаблон и и создать его экземпляр где угодно на странице.
        </div>
      </div>
    </div>
  </div>

  <div style="width: 100%;" class="card card-detail ac-six">
    <div class="card-wrapper ac-six">
      <div class="card-header ac-six">ViewChild, ElementRef, TemplateRef, ViewContainerRef</div>
      <div class="card-content ac-six">
        <div>
          ViewChild: получает доступ к DOM элементу и предоставляет API  для нативного взаимодействия, так и через API компонента. 
          В случае нативного взаимодейстия он возвращает ElementRef и использует проперти nativeElement. В случае компонента возвращает ссылку на экземпляр класса компонента его публичные методы.
          C точки зрения применения nativeElement можно использовать для вычисления ширины выпадающего списка из select компонента 
          nativeElement.getBoundingClientRect().width для динамического расчета.
        </div>
        <div>
          ElementRef: апи над нативным DOM. Можно использовать в директивах и добавлять различные классы к элементу.
          ElementRef на текущий элемент можно получить прямо из конструктора компонента. Применяется в кнопках, input, tooltip  и т.д. 
        </div>
        <div>
          TemplateRef: это ссылка на шаблон, его можно испльзовать для создания динамических input компонентов для передачи туда раздичных аффиксов. 
          Можно также передавать список шаблонов действий для динамических действий или меню.
        </div>
        <div>
          ViewContainerRef: предоставляет API для динамического создания новых компонентов представлений в текущем компоненте.
          Например в автокомплите для создания списка элементов. 
          </div>
      </div>
    </div>
  </div>

  <div style="width: 100%;" class="card card-detail pr-five">
    <div class="card-wrapper pr-five">
      <div class="card-header pr-five">ControlValueAccessor</div>
      <div class="card-content pr-five">
        <div>
          ControlValueAccessor: интерфейс состоящий из четырех методов  writeValue(value: any),
          registerOnChange,
          registerOnTouched, 
          setDisabledState.
          Он служить для того чтобы работали  Angular привязки и можно было использовать ngModel или реактивные формы.
          простой input имеет встроенную поддержку этого функционала, но другие сложные элементы вседа потребуют реализации этого интерфейса.
          <br/>
          https://habr.com/ru/company/tinkoff/blog/443714/
        </div>
      </div>
    </div>
  </div>

  <div style="width: 100%;" class="card card-detail ac-six">
    <div class="card-wrapper ac-six">
      <div class="card-header ac-six">ChangeDetectionStrategy, ChangeDetectorRef</div>
      <div class="card-content ac-six">
        <div>
          ChangeDetectionStrategy: По умолчанию Angular использует ChangeDetectionStrategy.Default стратегию обнаружения изменений.
          ChangeDetectionStrategy.Default работает таким образом, что каждый раз, когда что-то меняется в нашем приложении, в результате различных пользовательских событий, таймеров, XHR, промисов и т.д., обнаружение изменений будет запускаться по всем компонентам.
          ChangeDetectionStrategy.OnPush.


          Это означает, что компонент теперь зависит только от @inputs() параметров, и будет проверятся только при таких условиях:
          1. Изменилась ссылка input параметра
          2. Событие внутри компонента или его потомках
          3. Ручной запуск обнаружения изменений
           <br />
          https://habr.com/ru/company/infopulse/blog/358860/
        </div>
        <div>
          ChangeDetectorRef: UiKit должен быть производительным, а значит нужно использовать стратегию обнаруженя изменений OnPush.
          Но тогда на наши плечи ложится управление изменениями. Для этого используется ChangeDetectorRef
           - позволяет взять управление механизмом отслеживания изменений полностью под свой контроль.
        </div>
      </div>
    </div>
  </div>

</div>